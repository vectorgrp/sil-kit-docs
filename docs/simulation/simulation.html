<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simulation &mdash; Vector SIL Kit 4.0.36 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="API" href="../api/api.html" />
    <link rel="prev" title="Developer Guide" href="../for-developers/developers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../contents.html" class="icon icon-home"> Vector SIL Kit
          </a>
              <div class="version">
                4.0.36
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Vector SIL Kit Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../for-users/users.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../for-developers/developers.html">Developer Guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Simulation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#properties-of-participants">Properties of Participants</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lifecycle-management">Lifecycle Management</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lifecycle-control">Lifecycle Control</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#lifecycle-service">Lifecycle Service</a></li>
<li class="toctree-l4"><a class="reference internal" href="#time-synchronization-service">Time Synchronization Service</a></li>
<li class="toctree-l4"><a class="reference internal" href="#system-monitor">System Monitor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#system-controller">System Controller</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#lifecycle-coordination-between-participants">Lifecycle Coordination Between Participants</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simulation-wide-lifecycle-system-state">Simulation-wide Lifecycle (System State)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#synchronized-simulation-run">Synchronized Simulation Run</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#simulation-overview">Simulation Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuration-of-the-simulation-step">Configuration of the Simulation Step</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timestamps-in-messages">Timestamps in Messages</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sil-kit-middleware">SIL Kit Middleware</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/demos.html">Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration/configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../licenses/license.html">SIL Kit License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../licenses/license.html#third-party-licenses">Third-Party Licenses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../contents.html">Vector SIL Kit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../contents.html" class="icon icon-home"></a> &raquo;</li>
      <li>Simulation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/simulation/simulation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="simulation">
<h1>Simulation<a class="headerlink" href="#simulation" title="Permalink to this heading"></a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#properties-of-participants" id="id4">Properties of Participants</a></p></li>
<li><p><a class="reference internal" href="#lifecycle-management" id="id5">Lifecycle Management</a></p>
<ul>
<li><p><a class="reference internal" href="#lifecycle-control" id="id6">Lifecycle Control</a></p>
<ul>
<li><p><a class="reference internal" href="#lifecycle-service" id="id7">Lifecycle Service</a></p></li>
<li><p><a class="reference internal" href="#time-synchronization-service" id="id8">Time Synchronization Service</a></p></li>
<li><p><a class="reference internal" href="#system-monitor" id="id9">System Monitor</a></p></li>
<li><p><a class="reference internal" href="#system-controller" id="id10">System Controller</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#lifecycle-coordination-between-participants" id="id11">Lifecycle Coordination Between Participants</a></p></li>
<li><p><a class="reference internal" href="#simulation-wide-lifecycle-system-state" id="id12">Simulation-wide Lifecycle (System State)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#synchronized-simulation-run" id="id13">Synchronized Simulation Run</a></p>
<ul>
<li><p><a class="reference internal" href="#simulation-overview" id="id14">Simulation Overview</a></p></li>
<li><p><a class="reference internal" href="#configuration-of-the-simulation-step" id="id15">Configuration of the Simulation Step</a></p></li>
<li><p><a class="reference internal" href="#timestamps-in-messages" id="id16">Timestamps in Messages</a></p></li>
<li><p><a class="reference internal" href="#sil-kit-middleware" id="id17">SIL Kit Middleware</a></p></li>
</ul>
</li>
</ul>
</div>
<p>The following chapter explains how a simulation using the SIL Kit works.
It first introduces the properties that affect the participants’ behavior towards other participants.
Then, the lifecycle of individual simulation participants and the overall simulation are detailed.
Afterwards, details about a simulation run with synchronized participants are presented.
The chapter closes with details about the middleware that the reference implementation of the SIL Kit uses.</p>
<section id="properties-of-participants">
<span id="sec-sim-types"></span><h2><a class="toc-backref" href="#id4">Properties of Participants</a><a class="headerlink" href="#properties-of-participants" title="Permalink to this heading"></a></h2>
<p>Generally, a SIL Kit participant can communicate with other participants without knowledge about their existence.
However, participants can register a <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration14ISystemMonitor30SetParticipantConnectedHandlerE27ParticipantConnectedHandler" title="SilKit::Services::Orchestration::ISystemMonitor::SetParticipantConnectedHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetParticipantConnectedHandler()</span></code></a> callback that notifies them once a new participant connects.
Analogously, they can register a <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration14ISystemMonitor33SetParticipantDisconnectedHandlerE30ParticipantDisconnectedHandler" title="SilKit::Services::Orchestration::ISystemMonitor::SetParticipantDisconnectedHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetParticipantDisconnectedHandler()</span></code></a> callback that notifies them when a participant disconnects.</p>
<p>However, participants can also use a lifecycle service that allows them to coordinate their startup and shutdown phase with other participants (see <a class="reference internal" href="#sec-sim-lifecycle-management"><span class="std std-ref">Lifecycle Coordination Between Participants</span></a>).
In addition, participants with a lifecycle can use the virtual time synchronization (see <a class="reference internal" href="#sec-sim-synchronization"><span class="std std-ref">Synchronized Simulation Run</span></a>).</p>
</section>
<section id="lifecycle-management">
<span id="sec-sim-lifecycle-management"></span><h2><a class="toc-backref" href="#id5">Lifecycle Management</a><a class="headerlink" href="#lifecycle-management" title="Permalink to this heading"></a></h2>
<p>The SIL Kit provides lifecycle management for individual participants and the overall simulation.
The following first introduces means to observe and control the lifecycle.
Afterwards, the lifecycle of synchronized participants and the lifecycle of the overall simulation are introduced.</p>
<section id="lifecycle-control">
<h3><a class="toc-backref" href="#id6">Lifecycle Control</a><a class="headerlink" href="#lifecycle-control" title="Permalink to this heading"></a></h3>
<p>There are two levels of granularity when it comes to lifecycle management: a local lifecycle that affects the state of an individual participant and a simulation-wide system Lifecycle.
The following introduces the three components that can affect and observe the individual and global lifecycle.</p>
<section id="lifecycle-service">
<span id="subsubsec-sim-lifecycle-lifecycleservice"></span><h4><a class="toc-backref" href="#id7">Lifecycle Service</a><a class="headerlink" href="#lifecycle-service" title="Permalink to this heading"></a></h4>
<p>The <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleServiceE" title="SilKit::Services::Orchestration::ILifecycleService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ILifecycleService</span></code></a> interface allows each participant to access various functions related to its lifecycle.
Users can register callbacks that trigger once a participant reaches certain states.
Available callbacks are <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService28SetCommunicationReadyHandlerE25CommunicationReadyHandler" title="SilKit::Services::Orchestration::ILifecycleService::SetCommunicationReadyHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetCommunicationReadyHandler()</span></code></a>, <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService14SetStopHandlerE11StopHandler" title="SilKit::Services::Orchestration::ILifecycleService::SetStopHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetStopHandler()</span></code></a>, and <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService18SetShutdownHandlerE15ShutdownHandler" title="SilKit::Services::Orchestration::ILifecycleService::SetShutdownHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetShutdownHandler()</span></code></a>.
Further, the lifecycle service provides access to the <a class="reference internal" href="../api/timeSyncService.html#_CPPv4N6SilKit8Services13Orchestration16ITimeSyncServiceE" title="SilKit::Services::Orchestration::ITimeSyncService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ITimeSyncService</span></code></a> interface, which grants access to the virtual time synchronization (see below).
If this service is not used, an additional <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService18SetStartingHandlerE15StartingHandler" title="SilKit::Services::Orchestration::ILifecycleService::SetStartingHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetStartingHandler()</span></code></a> can be registered that notifies users once a simulation starts.
Once all needed controllers are registered and, if needed, the time synchronization service was retrieved and configured, the participants’ lifecycle can be published by calling <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService14StartLifecycleEv" title="SilKit::Services::Orchestration::ILifecycleService::StartLifecycle"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">StartLifecycle()</span></code></a> (see <a class="reference internal" href="#sec-sim-lifecycle-syncparticipants"><span class="std std-ref">Lifecycle Coordination Between Participants</span></a>).</p>
</section>
<section id="time-synchronization-service">
<span id="subsubsec-sim-lifecycle-timesyncservice"></span><h4><a class="toc-backref" href="#id8">Time Synchronization Service</a><a class="headerlink" href="#time-synchronization-service" title="Permalink to this heading"></a></h4>
<p>The <a class="reference internal" href="../api/timeSyncService.html#_CPPv4N6SilKit8Services13Orchestration16ITimeSyncServiceE" title="SilKit::Services::Orchestration::ITimeSyncService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ITimeSyncService</span></code></a> interface allows users to set a simulation step, which is important for participants with virtual time synchronization.
A simulation step defines the operations that are repeatedly performed in the interval of the simulation step size.
The simulation step as well as the initial step size are configured via <a class="reference internal" href="../api/timeSyncService.html#_CPPv4N6SilKit8Services13Orchestration16ITimeSyncService24SetSimulationStepHandlerE21SimulationStepHandlerNSt6chrono11nanosecondsE" title="SilKit::Services::Orchestration::ITimeSyncService::SetSimulationStepHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ITimeSyncService::SetSimulationStepHandler()</span></code></a></p>
</section>
<section id="system-monitor">
<span id="subsubsec-sim-lifecycle-systemmonitor"></span><h4><a class="toc-backref" href="#id9">System Monitor</a><a class="headerlink" href="#system-monitor" title="Permalink to this heading"></a></h4>
<p>To observe the state transitions of other participants, users first need to retrieve the <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration14ISystemMonitorE" title="SilKit::Services::Orchestration::ISystemMonitor"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ISystemMonitor</span></code></a> interface via <a class="reference internal" href="../api/participant.html#_CPPv4N6SilKit12IParticipant19CreateSystemMonitorEv" title="SilKit::IParticipant::CreateSystemMonitor"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">CreateSystemMonitor()</span></code></a>.
Afterwards, they can register a participant status callback via <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration14ISystemMonitor27AddParticipantStatusHandlerE24ParticipantStatusHandler" title="SilKit::Services::Orchestration::ISystemMonitor::AddParticipantStatusHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AddParticipantStatusHandler()</span></code></a>.
In addition, users can register a callback for changes of the overall system state via <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration14ISystemMonitor21AddSystemStateHandlerE18SystemStateHandler" title="SilKit::Services::Orchestration::ISystemMonitor::AddSystemStateHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AddSystemStateHandler()</span></code></a>.
The system state corresponds to the earliest state of all required participants.
For example, two Participants A and B are required. A is in state <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState10ReadyToRunE" title="SilKit::Services::Orchestration::ParticipantState::ReadyToRun"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">ReadyToRun</span></code></a> and B is in <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState7RunningE" title="SilKit::Services::Orchestration::ParticipantState::Running"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Running</span></code></a>, then the system state would be <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration11SystemState10ReadyToRunE" title="SilKit::Services::Orchestration::SystemState::ReadyToRun"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">ReadyToRun</span></code></a> (as Running follows ReadyToRun).</p>
</section>
<section id="system-controller">
<span id="subsubsec-sim-lifecycle-systemcontroller"></span><h4><a class="toc-backref" href="#id10">System Controller</a><a class="headerlink" href="#system-controller" title="Permalink to this heading"></a></h4>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The System Controller is experimental and might be changed or removed in future versions of the SIL Kit.</p>
</div>
<p>The <a class="reference internal" href="../api/systemcontroller.html#_CPPv4N6SilKit12Experimental8Services13Orchestration17ISystemControllerE" title="SilKit::Experimental::Services::Orchestration::ISystemController"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ISystemController</span></code></a> interface allows users to set system-wide simulation parameters, such as which participants
are required for a simulation, as well as signal commands that are processed by all participants with a
lifecycle (see <a class="reference internal" href="../api/systemcontroller.html"><span class="doc">System Controller</span></a> for details).</p>
<div class="admonition-note admonition">
<p class="admonition-title">Note</p>
<p>A coordinated participant must be required, or otherwise the simulation will enter an error state.</p>
</div>
</section>
</section>
<section id="lifecycle-coordination-between-participants">
<span id="sec-sim-lifecycle-syncparticipants"></span><h3><a class="toc-backref" href="#id11">Lifecycle Coordination Between Participants</a><a class="headerlink" href="#lifecycle-coordination-between-participants" title="Permalink to this heading"></a></h3>
<p>Each participant has an independent lifecycle that other participants can observe through the <a class="reference internal" href="#subsubsec-sim-lifecycle-systemmonitor"><span class="std std-ref">System Monitor</span></a>.</p>
<figure class="align-center" id="id1">
<span id="label-sim-lifecycle"></span><a class="reference internal image-reference" href="../_images/ParticipantLifecycle_3.png"><img alt=": Participant state machine" src="../_images/ParticipantLifecycle_3.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 7 </span><span class="caption-text">: SIL Kit participant state machine.</span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>A participant enters the distributed state machine by calling <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService14StartLifecycleEv" title="SilKit::Services::Orchestration::ILifecycleService::StartLifecycle"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">StartLifecycle()</span></code></a>.
This will cause the <a class="reference internal" href="#subsubsec-sim-lifecycle-lifecycleservice"><span class="std std-ref">Lifecycle Service</span></a> to announce its state as <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState15ServicesCreatedE" title="SilKit::Services::Orchestration::ParticipantState::ServicesCreated"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">ServicesCreated</span></code></a>, indicating that all services were created and announced to other participants.</p>
<p>A participant that uses the lifecycle service may choose to coordinate its state with other participants.
In that case, they will align their participant state based on the current system state until they reach <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState24CommunicationInitializedE" title="SilKit::Services::Orchestration::ParticipantState::CommunicationInitialized"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">CommunicationInitialized</span></code></a>.
Once the system state also changes to CommunicationInitialized, the communication between all participants via <a class="reference internal" href="../api/pubsub.html#_CPPv4N6SilKit8Services6PubSub14IDataPublisherE" title="SilKit::Services::PubSub::IDataPublisher"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">DataPublisher</span></code></a> and <a class="reference internal" href="../api/pubsub.html#_CPPv4N6SilKit8Services6PubSub15IDataSubscriberE" title="SilKit::Services::PubSub::IDataSubscriber"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">DataSubscriber</span></code></a> is possible.
This information is propagated to the user if they registered the callback via <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService28SetCommunicationReadyHandlerE25CommunicationReadyHandler" title="SilKit::Services::Orchestration::ILifecycleService::SetCommunicationReadyHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetCommunicationReadyHandler()</span></code></a>.
Once the callback is finished, the participant state changes to <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState10ReadyToRunE" title="SilKit::Services::Orchestration::ParticipantState::ReadyToRun"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">ReadyToRun</span></code></a>.
The participant will wait for the system state to change to <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration11SystemState10ReadyToRunE" title="SilKit::Services::Orchestration::SystemState::ReadyToRun"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">ReadyToRun</span></code></a> as well and then proceeds to the <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState7RunningE" title="SilKit::Services::Orchestration::ParticipantState::Running"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Running</span></code></a> state.</p>
<p>During the execution of a <code class="docutils literal notranslate"><span class="pre">CommunicationReadyHandler</span></code>, the network communication of the participant is blocked. Therefore, it is impossible to exchange information with other participants during the execution of a <code class="docutils literal notranslate"><span class="pre">CommunicationReadyHandler</span></code>.
If it is necessary to exchange information during the <code class="docutils literal notranslate"><span class="pre">CommunicationInitialized</span></code> state, <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService33SetCommunicationReadyHandlerAsyncE25CommunicationReadyHandler" title="SilKit::Services::Orchestration::ILifecycleService::SetCommunicationReadyHandlerAsync"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetCommunicationReadyHandlerAsync()</span></code></a> and <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService38CompleteCommunicationReadyHandlerAsyncEv" title="SilKit::Services::Orchestration::ILifecycleService::CompleteCommunicationReadyHandlerAsync"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">CompleteCommunicationReadyHandlerAsync()</span></code></a> can be used.
<a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService33SetCommunicationReadyHandlerAsyncE25CommunicationReadyHandler" title="SilKit::Services::Orchestration::ILifecycleService::SetCommunicationReadyHandlerAsync"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetCommunicationReadyHandlerAsync()</span></code></a> signals that the <code class="docutils literal notranslate"><span class="pre">CommunicationInitialized</span></code> state has been reached. After its execution, a participant is still in the <code class="docutils literal notranslate"><span class="pre">CommunicationInitialized</span></code> state and can exchange information.
After <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService38CompleteCommunicationReadyHandlerAsyncEv" title="SilKit::Services::Orchestration::ILifecycleService::CompleteCommunicationReadyHandlerAsync"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">CompleteCommunicationReadyHandlerAsync()</span></code></a> is called, the participants state will switch to participant state changes to <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState10ReadyToRunE" title="SilKit::Services::Orchestration::ParticipantState::ReadyToRun"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">ReadyToRun</span></code></a>.</p>
<p>Participants that coordinate their state but do not use the virtual time synchronization can register a <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService18SetStartingHandlerE15StartingHandler" title="SilKit::Services::Orchestration::ILifecycleService::SetStartingHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetStartingHandler()</span></code></a>, which indicates that the synchronized participants will start the virtual time synchronization and thus the simulation.
This callback does not block the other participants and should only be used to start timers etc., it will trigger when the state transition to <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState7RunningE" title="SilKit::Services::Orchestration::ParticipantState::Running"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Running</span></code></a> is imminent.</p>
<p>Participants may also choose not to coordinate their state with other participants.
In this case, their state will transition to the Running phase without waiting for any system states.
They still receive the <code class="docutils literal notranslate"><span class="pre">CommunicationReady</span></code> callback before changing to <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState10ReadyToRunE" title="SilKit::Services::Orchestration::ParticipantState::ReadyToRun"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">ReadyToRun</span></code></a>, but the communication guarantee does not apply.</p>
<p>Participants that use the virtual time synchronization repeatedly execute their registered simulation steps while advancement of time is handled by the middleware implementation.
If a participant temporarily cannot advance the simulation, e.g., because a debugger is attached to investigate its internal state, a participant can be put into the <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState6PausedE" title="SilKit::Services::Orchestration::ParticipantState::Paused"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Paused</span></code></a> state.</p>
<p>Generally, any participant can stop its simulation run by calling <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService4StopENSt6stringE" title="SilKit::Services::Orchestration::ILifecycleService::Stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Stop()</span></code></a>.
If the participant is part of the required participants of a simulation, all other coordinated participants will also stop their simulation.
Please note that participants that are not coordinated must call stop by themselves to end their simulation run regularly.</p>
<p>Coordinated participants will also stop their simulation if the system state changes to <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState8StoppingE" title="SilKit::Services::Orchestration::ParticipantState::Stopping"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Stopping</span></code></a>.
A callback registered via <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService14SetStopHandlerE11StopHandler" title="SilKit::Services::Orchestration::ILifecycleService::SetStopHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetStopHandler()</span></code></a> can be used to detect the state transition and perform a collection of simulation results.
Once the callback execution is finished, the participant will change its state to <code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Stop</span></code>.
Afterwards, they transition to the <code class="docutils literal notranslate"><span class="pre">ShuttingDown</span></code> state, call the <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService18SetShutdownHandlerE15ShutdownHandler" title="SilKit::Services::Orchestration::ILifecycleService::SetShutdownHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetShutdownHandler()</span></code></a> and transition to the <code class="docutils literal notranslate"><span class="pre">Shutdown</span></code> state.</p>
<p>Whenever a participant encounters an error from which it cannot recover, it switches to the <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState5ErrorE" title="SilKit::Services::Orchestration::ParticipantState::Error"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Error</span></code></a> state to indicate this situation to the system.
Users can manually trigger a transition to the error state and provide more information about the cause by calling <a class="reference internal" href="../api/lifecycleService.html#_CPPv4N6SilKit8Services13Orchestration17ILifecycleService11ReportErrorENSt6stringE" title="SilKit::Services::Orchestration::ILifecycleService::ReportError"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ReportError()</span></code></a>.
In some situations, a lifecycle service automatically enters the error state, e.g., when an uncaught exception is thrown in a callback.
A participant can only recover from the <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState5ErrorE" title="SilKit::Services::Orchestration::ParticipantState::Error"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Error</span></code></a> state in one way: by shutting down.</p>
<p>All participants can also be forced to end their lifecycle by calling <a class="reference internal" href="../api/systemcontroller.html#_CPPv4NK6SilKit12Experimental8Services13Orchestration17ISystemController15AbortSimulationEv" title="SilKit::Experimental::Services::Orchestration::ISystemController::AbortSimulation"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">AbortSimulation()</span></code></a> from any participant.
This will trigger the <code class="docutils literal notranslate"><span class="pre">Abort</span></code> callback, which indicates that the simulation was aborted and provide the participant state that was active when the abort event was received.</p>
</section>
<section id="simulation-wide-lifecycle-system-state">
<span id="subsec-sim-lifecycle"></span><h3><a class="toc-backref" href="#id12">Simulation-wide Lifecycle (System State)</a><a class="headerlink" href="#simulation-wide-lifecycle-system-state" title="Permalink to this heading"></a></h3>
<p>The lifecycle of the overall simulation is derived from the states of a defined set of participants.
Changes to the system state can be observed via the System Monitor.</p>
<p>The set of participants that define the system state must be defined via <a class="reference internal" href="../api/systemcontroller.html#_CPPv4N6SilKit12Experimental8Services13Orchestration17ISystemController24SetWorkflowConfigurationERKN6SilKit8Services13Orchestration21WorkflowConfigurationE" title="SilKit::Experimental::Services::Orchestration::ISystemController::SetWorkflowConfiguration"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetWorkflowConfiguration()</span></code></a> before the simulation is started (see <a class="reference internal" href="#subsubsec-sim-lifecycle-systemcontroller"><span class="std std-ref">above</span></a> for details).
The system state is defined as follows:</p>
<ol class="arabic simple">
<li><p>If any required participant is not available, the system state is <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState7InvalidE" title="SilKit::Services::Orchestration::ParticipantState::Invalid"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Invalid</span></code></a>.</p></li>
<li><p>If all required participants are in the same state, the system state will also be in this state. For example, if all required participants are in the state <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState7RunningE" title="SilKit::Services::Orchestration::ParticipantState::Running"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Running</span></code></a>, the system state is <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration11SystemState7RunningE" title="SilKit::Services::Orchestration::SystemState::Running"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Running</span></code></a> too.</p></li>
<li><p>If not all required participants are in the same state, the ‘earliest’ state is used. For example, if a required participant ‘A’ is in <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState24CommunicationInitializedE" title="SilKit::Services::Orchestration::ParticipantState::CommunicationInitialized"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">CommunicationInitialized</span></code></a> and a required participant ‘B’ is in <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState10ReadyToRunE" title="SilKit::Services::Orchestration::ParticipantState::ReadyToRun"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">ReadyToRun</span></code></a>, then the system state is <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration11SystemState24CommunicationInitializedE" title="SilKit::Services::Orchestration::SystemState::CommunicationInitialized"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">CommunicationInitialized</span></code></a>.</p></li>
</ol>
<p>The main exception to this rule are the <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState6PausedE" title="SilKit::Services::Orchestration::ParticipantState::Paused"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Paused</span></code></a>, <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState5ErrorE" title="SilKit::Services::Orchestration::ParticipantState::Error"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Error</span></code></a>, and <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState8StoppingE" title="SilKit::Services::Orchestration::ParticipantState::Stopping"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Stopping</span></code></a> states, which can be regarded as dominant states.
For example, if just one participant enters the <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState5ErrorE" title="SilKit::Services::Orchestration::ParticipantState::Error"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Error</span></code></a> state, the system state will be change to <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration11SystemState5ErrorE" title="SilKit::Services::Orchestration::SystemState::Error"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Error</span></code></a> as well.</p>
<p>The system state follows state transitions in a lazy manner.
This means that the system state remains the old state until all relevant participants have reached the new state.
For example, the system state remains <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration11SystemState15ServicesCreatedE" title="SilKit::Services::Orchestration::SystemState::ServicesCreated"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">ServicesCreated</span></code></a> until all relevant participants have achieved the <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration16ParticipantState25CommunicationInitializingE" title="SilKit::Services::Orchestration::ParticipantState::CommunicationInitializing"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">CommunicationInitializing</span></code></a> state.</p>
<p>In all cases that do not match any of the above, the system state will be regarded as <a class="reference internal" href="../api/systemmonitor.html#_CPPv4N6SilKit8Services13Orchestration11SystemState7InvalidE" title="SilKit::Services::Orchestration::SystemState::Invalid"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">Invalid</span></code></a>.
This should typically not occur.</p>
</section>
</section>
<section id="synchronized-simulation-run">
<span id="sec-sim-synchronization"></span><h2><a class="toc-backref" href="#id13">Synchronized Simulation Run</a><a class="headerlink" href="#synchronized-simulation-run" title="Permalink to this heading"></a></h2>
<p>The following first gives a general overview of a simulation run using the SIL Kit.
Afterwards, possibilities to configure the simulation step length of a simulation step and to define the simulation step that is being executed are introduced.
The last part details what time information SIL Kit clients provide, depending on their synchronization mode.</p>
<div class="admonition-note admonition">
<p class="admonition-title">Note</p>
<p>A mixed operation mode, where some participants operate synchronized and some unsynchronized,
is not supported. Therefore, all participants of a simulation must either be synchronized or unsynchronized.</p>
</div>
<section id="simulation-overview">
<span id="subsec-sim-overview"></span><h3><a class="toc-backref" href="#id14">Simulation Overview</a><a class="headerlink" href="#simulation-overview" title="Permalink to this heading"></a></h3>
<p>A SIL Kit simulation is designed as a discrete-event simulation.
This means, that each event of a participant occurs at a distinct point in time.
Synchronized participants exchange information about the next point in time at which they intend to execute their <em>simulation step</em>.
Based on this information they can infer if they can trigger their next simulation step or if they still need to wait for other participants to finish their steps.
Each participant executes its simulation step periodically.
The simulation time between the execution must be set when registering the simulation step.</p>
</section>
<section id="configuration-of-the-simulation-step">
<h3><a class="toc-backref" href="#id15">Configuration of the Simulation Step</a><a class="headerlink" href="#configuration-of-the-simulation-step" title="Permalink to this heading"></a></h3>
<p>Each synchronized participant <strong>must</strong> define a simulation step that will be executed at the beginning of the interval defined by the simulation step size.
The size of the simulation step is provided when setting the simulation step handler.
Users can provide the simulation step either synchronously or asynchronously.
The synchronous simulation step is set by calling <a class="reference internal" href="../api/timeSyncService.html#_CPPv4N6SilKit8Services13Orchestration16ITimeSyncService24SetSimulationStepHandlerE21SimulationStepHandlerNSt6chrono11nanosecondsE" title="SilKit::Services::Orchestration::ITimeSyncService::SetSimulationStepHandler"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetSimulationStepHandler()</span></code></a>
and providing the simulation step to be executed as a delegate function.
Note that the simulation step is not necessarily executed on the main thread of the application.
After the execution of the simulation step is finished, the other participants are informed about the next point in time at which the participant intends to execute its next step.
Users can exchange the simulation step by calling <code class="docutils literal notranslate"><span class="pre">SetSimulationStepHandler</span></code> again, but they cannot intervene during its execution.</p>
<p>Sometimes, it may be desirable to have more control about the simulation step execution.
In these cases, the asynchronous simulation step execution may be preferable.</p>
<p>Similar to the synchronous case, an asynchronous simulation step is set by calling <a class="reference internal" href="../api/timeSyncService.html#_CPPv4N6SilKit8Services13Orchestration16ITimeSyncService29SetSimulationStepHandlerAsyncE21SimulationStepHandlerNSt6chrono11nanosecondsE" title="SilKit::Services::Orchestration::ITimeSyncService::SetSimulationStepHandlerAsync"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SetSimulationStepHandlerAsync()</span></code></a>.
It is executed at the start of each simulation step, but it does not automatically signal other participants that the current simulation step is finished.
Instead, the user is required to call <a class="reference internal" href="../api/timeSyncService.html#_CPPv4N6SilKit8Services13Orchestration16ITimeSyncService22CompleteSimulationStepEv" title="SilKit::Services::Orchestration::ITimeSyncService::CompleteSimulationStep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">CompleteSimulationStep()</span></code></a> to signal the completion of the current simulation step.
This enables the user to have fine-grained control over the synchronous simulation progress.
Also, this allows two participants to communicate without increasing the simulation time.</p>
<div class="admonition-note admonition">
<p class="admonition-title">Note</p>
<p>Asynchronous simulation steps are non-blocking.
This means that it is possible that callbacks from received messages are triggered concurrently during the execution of the simulation step.
Users need to make sure that their data is protected against concurrent read/write access.</p>
</div>
<div class="admonition-note admonition">
<p class="admonition-title">Note</p>
<p>Calling <a class="reference internal" href="../api/timeSyncService.html#_CPPv4N6SilKit8Services13Orchestration16ITimeSyncService22CompleteSimulationStepEv" title="SilKit::Services::Orchestration::ITimeSyncService::CompleteSimulationStep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">CompleteSimulationStep()</span></code></a> will advance the simulation time regardless of the execution state of the asynchronous simulation step.</p>
</div>
</section>
<section id="timestamps-in-messages">
<span id="subsec-sim-sync-timestamps"></span><h3><a class="toc-backref" href="#id16">Timestamps in Messages</a><a class="headerlink" href="#timestamps-in-messages" title="Permalink to this heading"></a></h3>
<p>Each sent bus event is annotated with a timestamp, at which it was sent.
The timestamp is set automatically by the SIL Kit client.
Users do not have to (and should not try to) manually set the timestamp of a message.
Depending on the mode of the participant (synchronized/unsynchronized) and whether the network is managed by a network simulator, the timestamp’s meaning and precision may differ.
If a network simulator is available for a given network, it takes precedence of the timestamp control and overrides the timestamps of any bus message.</p>
<p>The following table provides an overview of the behavior, if no network simulator is available.</p>
<table class="colwidths-given docutils align-default" id="id2">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">: Message timestamp by synchronization mode</span><a class="headerlink" href="#id2" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 30%" />
<col style="width: 35%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>Unsynchronized (Sender)</p></th>
<th class="head"><p>Synchronized (Sender)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Unsynchronized (Receiver)</p></td>
<td><p>Undefined</p></td>
<td><p>Use timestamp of own simulation step</p></td>
</tr>
<tr class="row-odd"><td><p>Synchronized (Receiver)</p></td>
<td><p>Undefined</p></td>
<td><p>Use timestamp of sender</p></td>
</tr>
</tbody>
</table>
</section>
<section id="sil-kit-middleware">
<span id="subsec-sim-syncexample"></span><h3><a class="toc-backref" href="#id17">SIL Kit Middleware</a><a class="headerlink" href="#sil-kit-middleware" title="Permalink to this heading"></a></h3>
<p>The provided implementation of the SIL Kit headers uses an internal middleware that is provided with the SIL Kit.
Within it, all participants exchange their messages via direct messaging based on TCP connections or Unix domain sockets.</p>
<p>The internal middleware guarantees message delivery to always be in-order.
This enables the usage of a distributed synchronization algorithm.
<a class="reference internal" href="#label-sim-messagedelivery"><span class="std std-numref">Figure 8</span></a> shows the synchronization algorithm:</p>
<figure class="align-center" id="id3">
<span id="label-sim-messagedelivery"></span><a class="reference internal image-reference" href="../_images/sim-inorder-strict.png"><img alt="Vector SIL Kit message delivery" src="../_images/sim-inorder-strict.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 8 </span><span class="caption-text">: SIL Kit delivery of messages.</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The algorithm reports the start time of the next due simulation step to all other participants (<code class="docutils literal notranslate"><span class="pre">next&#64;</span></code> messages in the figure).
By taking the other participants’ next simulation step into account, a participant knows when it can safely execute its next simulation step.
That is, when there are no more simulation steps of other participants with an earlier timestamp than its own next simulation step.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../for-developers/developers.html" class="btn btn-neutral float-left" title="Developer Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../api/api.html" class="btn btn-neutral float-right" title="API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 Vector Informatik GmbH.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>